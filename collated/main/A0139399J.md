# A0139399J
###### \java\seedu\doit\logic\commands\MarkCommand.java
``` java
package seedu.doit.logic.commands;

import seedu.doit.commons.core.Messages;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.logic.commands.exceptions.CommandException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.UniqueTaskList;

public class MarkCommand extends Command {
    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
        + ": Marks the task identified by the index number used in the last task list as completed.\n"
        + "Parameters: INDEX (must be a positive integer)\n"
        + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    public final int filteredTaskListIndex;

    public MarkCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList = model.getFilteredTaskList();

        if (filteredTaskListIndex <= lastShownTaskList.size()) {
            ReadOnlyTask taskToMark = lastShownTaskList.get(filteredTaskListIndex - 1);

            try {
                model.markTask(filteredTaskListIndex - 1, taskToMark);
            } catch (UniqueTaskList.TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }

            return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
        } else {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }
}
```
###### \java\seedu\doit\logic\commands\UnmarkCommand.java
``` java
package seedu.doit.logic.commands;

import seedu.doit.commons.core.EventsCenter;
import seedu.doit.commons.core.Messages;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.events.ui.JumpToListRequestEvent;
import seedu.doit.logic.commands.exceptions.CommandException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.UniqueTaskList;

public class UnmarkCommand extends Command {
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
        + ": Changes the task identified by the index number used in the last task list to uncompleted.\n"
        + "Parameters: INDEX (must be a positive integer)\n"
        + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    public final int filteredTaskListIndex;

    public UnmarkCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList = this.model.getFilteredTaskList();

        if (this.filteredTaskListIndex <= lastShownTaskList.size()) {
            ReadOnlyTask taskToUnmark = lastShownTaskList.get(this.filteredTaskListIndex - 1);

            try {
                this.model.unmarkTask(this.filteredTaskListIndex - 1, taskToUnmark);
            } catch (UniqueTaskList.TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            EventsCenter.getInstance().post(new JumpToListRequestEvent(
                    this.model.getFilteredTaskList().indexOf(taskToUnmark)));
            return new CommandResult(String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToUnmark));
        } else {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }
}
```
###### \java\seedu\doit\logic\parser\CommandParser.java
``` java
package seedu.doit.logic.parser;

import seedu.doit.logic.commands.Command;

public interface CommandParser {

    /**
     * Parses the given {@code String} of arguments
     * and returns a Command object for execution.
     */
    Command parse(String args);

}
```
###### \java\seedu\doit\logic\parser\UnmarkCommandParser.java
``` java
package seedu.doit.logic.parser;

import static seedu.doit.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.doit.logic.commands.Command;
import seedu.doit.logic.commands.IncorrectCommand;
import seedu.doit.logic.commands.UnmarkCommand;


/**
 * Parses input arguments and creates a new MarkCommand object
 */
public class UnmarkCommandParser implements CommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns an MarkCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }

        return new UnmarkCommand(index.get());
    }

}
```
###### \java\seedu\doit\model\comparators\EndTimeComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their endTime
 */
public class EndTimeComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare endTime or name if endTime == null
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            switch(currType) {
            case 1:
                //fallthrough
            case 2:
                return compareEndTime(curr, other);
            default:
                return compareName(curr, other);
            }
        }
        return compareInt;
    }

    private int compareEndTime(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getDeadline().compareTo(other.getDeadline());
    }

    private int compareName(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getName().toString().compareToIgnoreCase(other.getName().toString());
    }

}
```
###### \java\seedu\doit\model\comparators\PriorityComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their priority
 */
public class PriorityComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare priority
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            return comparePriority(curr, other);
        }
        return compareInt;
    }

    private int comparePriority(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getPriority().compareTo(other.getPriority());
    }

}
```
###### \java\seedu\doit\model\comparators\StartTimeComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their startTime
 */
public class StartTimeComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare startTime or name if startTime == null
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            switch(currType) {
            case 2:
                return compareStartTime(curr, other);
            default:
                return compareName(curr, other);
            }
        }
        return compareInt;
    }

    private int compareStartTime(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getStartTime().compareTo(other.getStartTime());
    }

    private int compareName(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getName().toString().compareToIgnoreCase(other.getName().toString());
    }

}
```
###### \java\seedu\doit\model\comparators\TaskComparator.java
``` java
package seedu.doit.model.comparators;

import java.util.Comparator;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Provides an interface for all TaskComparator classes to compare ReadOnlyTasks
 */
public interface TaskComparator extends Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2);

}
```
###### \java\seedu\doit\model\comparators\TaskNameComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their names in lexicographical order
 */
public class TaskNameComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare names
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            return compareName(curr, other);
        }
        return compareInt;
    }

    private int compareName(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getName().toString().compareToIgnoreCase(other.getName().toString());
    }
}
```
###### \java\seedu\doit\model\item\Description.java
``` java
package seedu.doit.model.item;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's description in the task manager. Guarantees: immutable;
 * is valid as declared in {@link #isValidDescription(String)}
 */
public class Description {
    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS =
        "Task description can take in any string";
    /*
     *  Any String is a valid description
     */
    public static final String DESCRIPTION_VALIDATION_REGEX = ".*";

    public final String value;

    /**
     * Validates given description.
     *
     * @throws IllegalValueException
     *             if given description string is invalid or null.
     */
    public Description(String description) throws IllegalValueException {
        if (description == null || !isValidDescription(description)) {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
        this.value = description;
    }

    /**
     * Returns true if a given string is a valid task description.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(DESCRIPTION_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Description // instanceof handles nulls
            && this.value.equals(((Description) other).value)); // state check
    }

}
```
###### \java\seedu\doit\model\item\EndTime.java
``` java
package seedu.doit.model.item;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.logic.parser.DateTimeParser;

/**
 * Represents a Item's end time in the item manager. Guarantees: immutable; is
 * valid as declared in {@link #isValidEndTime(String)}
 */
public class EndTime  implements Comparable<EndTime> {

    public static final String NO_END_TIME = null;
    public static final String MESSAGE_ENDTIME_CONSTRAINTS = "Item End Time should be in "
        + "MM-DD-YY HH:MM Format or relative date today, tomorrow, next wednesday";
    public static final String ENDTIME_VALIDATION_REGEX = "^([0-9]||0[0-9]||1[0-2])/([0-2][0-9]||3[0-1])"
        + "/([0-9][0-9])?[0-9][0-9] [0-2]\\d:[0-6]\\d$";

    public final String value;
    private final LocalDateTime dateObject;


    /**
     * Gives a NO_END_TIME which represents there is no end time.
     */
    public EndTime() {
        this.value = NO_END_TIME;
        this.dateObject = null;
    }

    /**
     * Validates given endTime.
     *
     * @throws IllegalValueException if given endTime string is invalid.
     */
    public EndTime(String endTime) throws IllegalValueException {
        if (endTime == NO_END_TIME) {
            this.value = NO_END_TIME;
            this.dateObject = null;
        } else {
            String trimmedEndTime = endTime.trim();

            dateObject = DateTimeParser.parseDateTime(trimmedEndTime)
                .orElseThrow(() -> new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS));

            String dateInString = formatDate(dateObject);

            if (!isValidEndTime(dateInString)) {
                throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
            }
            this.value = dateInString;
        }
    }

    /**
     * Returns if a given string is a valid item end time.
     */
    public static boolean isValidEndTime(String test) {
        return test.matches(ENDTIME_VALIDATION_REGEX);
    }

    private static String formatDate(LocalDateTime input) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yy HH:mm");
        return input.format(formatter);
    }

    @Override
    public String toString() {
        return this.value;
    }

    @Override
    public boolean equals(Object other) {
        return (other == this // short circuit if same object
            ) || ((other instanceof EndTime // instanceof handles nulls
            ) && this.value.equals(((EndTime) other).value)); // state check
    }

    @Override
    public int compareTo(EndTime other) {
        return this.value.compareTo(other.value);
    }

    public LocalDateTime getDateTimeObject() {
        return this.dateObject;
    }

}
```
###### \java\seedu\doit\model\item\Name.java
``` java
package seedu.doit.model.item;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's name in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS =
        "Task names should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the task must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String NAME_VALIDATION_REGEX = "^[^-\\s][a-zA-Z0-9_\\s-]+$";

    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Name // instanceof handles nulls
            && this.fullName.equals(((Name) other).fullName)); // state check
    }

}
```
###### \java\seedu\doit\model\item\Priority.java
``` java
package seedu.doit.model.item;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's priority in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements Comparable<Priority> {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should only be low med high";
    public static final String PRIORITY_VALIDATION_REGEX = "(low)|(med)|(high)";
    public static final String PRIORITY_LOW = "low";
    public static final String PRIORITY_MED = "med";

    public final String value;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        String trimmedPriority = priority.trim();
        if (!isValidPriority(trimmedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
        this.value = trimmedPriority;
    }

    /**
     * Returns true if a given string is a valid task priority.
     */
    public static boolean isValidPriority(String test) {
        return test.matches(PRIORITY_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Priority // instanceof handles nulls
            && this.value.equals(((Priority) other).value)); // state check
    }

    private int getPriorityValue() {
        if (PRIORITY_LOW.equals(value)) {
            return 3;
        } else if (PRIORITY_MED.equals(value)) {
            return 2;
        } else {
            return 1;
        }
    }

    @Override
    public int compareTo(Priority other) {
        Integer currPriorityValue = getPriorityValue();
        Integer otherPriorityValue = other.getPriorityValue();
        return currPriorityValue.compareTo(otherPriorityValue);
    }

}
```
###### \java\seedu\doit\model\item\ReadOnlyTask.java
``` java
package seedu.doit.model.item;

import seedu.doit.model.tag.UniqueTagList;

/**
 * A read-only immutable interface for a Task in the task manager.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Name getName();

    Priority getPriority();

    Description getDescription();

    StartTime getStartTime();

    EndTime getDeadline();

    boolean getIsDone();

    /**
     * The returned TagList is a deep copy of the internal TagList, changes on
     * the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
            || (other != null // this is first to avoid NPE below
            && other.getName().equals(this.getName()) // state checks here onwards
            && other.getPriority().equals(this.getPriority())
            && other.getDescription().equals(this.getDescription())
            && (other.getIsDone() == this.getIsDone()));
    }

    /**
     * Formats the event as text, showing all details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();;

        appendName(builder);
        appendPriority(builder);
        appendStartTime(builder);
        appendEndTime(builder);
        appendDescription(builder);
        appendTags(builder);

        return builder.toString();
    }

    default void appendName(StringBuilder builder) {
        builder.append(getName());
    }

    default void appendPriority(StringBuilder builder) {
        builder.append(" Priority: ");
        builder.append(getPriority());
    }

    default void appendStartTime(StringBuilder builder) {
        if (hasStartTime()) {
            builder.append(" Start Time: ");
            builder.append(getStartTime());
        }
    }

    default void appendEndTime(StringBuilder builder) {
        if (hasEndTime()) {
            builder.append(" End Time: ");
            builder.append(getDeadline());
        }
    }

    default void appendDescription(StringBuilder builder) {
        builder.append(" Description: ");
        builder.append(getDescription());
    }

    default void appendTags(StringBuilder builder) {
        builder.append(" Tags: ");
        getTags().forEach(builder::append);
    }

    boolean hasStartTime();

    boolean hasEndTime();

    int getItemType();

    boolean isTask();

    boolean isEvent();

    boolean isFloatingTask();
}
```
###### \java\seedu\doit\model\item\StartTime.java
``` java
package seedu.doit.model.item;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.logic.parser.DateTimeParser;

/**
 * Represents a Item's start time in the task manager. Guarantees: immutable; is
 * valid as declared in {@link #isValidStartTime(String)}
 */
public class StartTime implements Comparable<StartTime> {

    public static final String NO_START_TIME = null;
    public static final String MESSAGE_STARTTIME_CONSTRAINTS = "Item Start Time should be in "
        + "MM-DD-YY HH:MM Format or relative date today, tomorrow, next wednesday";
    public static final String STARTTIME_VALIDATION_REGEX = "^([0-9]||0[0-9]||1[0-2])/([0-2][0-9]||3[0-1])"
        + "/([0-9][0-9])?[0-9][0-9] [0-2]\\d:[0-6]\\d$";

    public final String value;
    private final LocalDateTime dateObject;

    /**
     * Gives a NO_START_TIME which represents there is no start time.
     */
    public StartTime() {
        this.value = NO_START_TIME;
        this.dateObject = null;
    }

    /**
     * Validates given startTime.
     *
     * @throws IllegalValueException if given startTime string is invalid.
     */
    public StartTime(String startTime) throws IllegalValueException {
        if (startTime == NO_START_TIME) {
            this.value = NO_START_TIME;
            this.dateObject = null;
        } else {
            String trimmedStartTime = startTime.trim();

            dateObject = DateTimeParser.parseDateTime(trimmedStartTime)
                .orElseThrow(() -> new IllegalValueException(MESSAGE_STARTTIME_CONSTRAINTS));

            String dateInString = formatDate(dateObject);

            if (!isValidStartTime(dateInString)) {
                throw new IllegalValueException(MESSAGE_STARTTIME_CONSTRAINTS);
            }

            this.value = dateInString;
        }
    }

    /**
     * Returns if a given string is a valid task start time.
     */
    public static boolean isValidStartTime(String test) {
        return test.matches(STARTTIME_VALIDATION_REGEX);
    }

    private static String formatDate(LocalDateTime input) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yy HH:mm");
        return input.format(formatter);

    }

    @Override
    public String toString() {
        return this.value;
    }

    @Override
    public boolean equals(Object other) {
        return (other == this // short circuit if same object
            ) || ((other instanceof StartTime// instanceof handles nulls
            ) && this.value.equals(((StartTime) other).value)); // state check
    }

    @Override
    public int compareTo(StartTime other) {
        return this.value.compareTo(other.value);
    }

    public LocalDateTime getDateTimeObject() {
        return this.dateObject;
    }

}
```
###### \java\seedu\doit\model\item\Task.java
``` java
package seedu.doit.model.item;

import java.util.Objects;

import seedu.doit.commons.util.CollectionUtil;
import seedu.doit.model.tag.UniqueTagList;

/**
 * Represents a Task in the task manager. Guarantees: details are present and
 * not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private Priority priority;
    private StartTime startTime;
    private EndTime endTime;
    private Description description;
    private boolean isDone;
    private UniqueTagList tags;

    // ================ Constructor methods ==============================

    /**
     * Event Constructor where every field must be present and not null.
     */
    public Task(Name name, Priority priority, StartTime startTime, EndTime endTime, Description description,
            UniqueTagList tags, boolean isDone) {
        assert !CollectionUtil.isAnyNull(name, startTime, endTime);
        this.name = name;
        this.priority = priority;
        this.startTime = startTime;
        this.endTime = endTime;
        this.description = description;
        this.isDone = isDone;
        this.tags = new UniqueTagList(tags); // protect internal tags from
                                             // changes in the arg list
    }

    /**
     * Event Constructor where every field must be present except isDone.
     */
    public Task(Name name, Priority priority, StartTime startTime, EndTime endTime, Description description,
            UniqueTagList tags) {
        this(name, priority, startTime, endTime, description, tags, false);
    }

    /**
     * Task Constructor every field must be present except for startTime and
     * isDone.
     */
    public Task(Name name, Priority priority, EndTime endTime, Description description, UniqueTagList tags,
            boolean isDone) {
        this(name, priority, new StartTime(), endTime, description, tags, isDone);
    }

    /**
     * Task Constructor every field must be present except for startTime.
     */
    public Task(Name name, Priority priority, EndTime endTime, Description description, UniqueTagList tags) {
        this(name, priority, new StartTime(), endTime, description, tags);
        assert !CollectionUtil.isAnyNull(name, endTime);
    }

    /**
     * FloatingTask Constructor every field must be present except for
     * startTime, endTime and isDone.
     */
    public Task(Name name, Priority priority, Description description, UniqueTagList tags, boolean isDone) {
        this(name, priority, new StartTime(), new EndTime(), description, tags, isDone);
    }

    /**
     * FloatingTask Constructor every field must be present except for startTime
     * and endTime.
     */
    public Task(Name name, Priority priority, Description description, UniqueTagList tags) {
        this(name, priority, new StartTime(), new EndTime(), description, tags);
        assert !CollectionUtil.isAnyNull(name);
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getPriority(), source.getDescription(), source.getTags());
        this.startTime = source.getStartTime();
        this.endTime = source.getDeadline();
        this.isDone = source.getIsDone();

    }

    // ================ Getter and Setter methods ==============================

    @Override
    public Name getName() {
        return this.name;
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Priority getPriority() {
        return this.priority;
    }

    public void setPriority(Priority priority) {
        assert priority != null;
        this.priority = priority;
    }

    @Override
    public boolean getIsDone() {
        return this.isDone;
    }

    public void setIsDone(boolean isDone) {
        this.isDone = isDone;
    }

    @Override
    public StartTime getStartTime() {
        return this.startTime;
    }

    public void setStartTime(StartTime startTime) {
        assert startTime != null;
        this.startTime = startTime;
    }

    @Override
    public EndTime getDeadline() {
        return this.endTime;
    }

    public void setEndTime(EndTime endTime) {
        assert endTime != null;
        this.endTime = endTime;
    }

    @Override
    public Description getDescription() {
        return this.description;
    }

    public void setDescription(Description description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public boolean hasStartTime() {
        if (this.startTime == null) {
            return false;
        } else if (this.startTime.value == null) {
            return false;
        }
        return true;
    }

    @Override
    public boolean hasEndTime() {
        if (this.endTime == null) {
            return false;
        } else if (this.endTime.value == null) {
            return false;
        }
        return true;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(this.tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        this.tags.setTags(replacement);
    }

    /**
     * Indicates if this item is an event
     */
    @Override
    public boolean isEvent() {
        return (hasStartTime() && hasEndTime());
    }

    /**
     * Indicates if this item is a floatingTask
     */
    @Override
    public boolean isFloatingTask() {
        return (!hasStartTime() && !hasEndTime());
    }

    /**
     * Indicates if this item is a task
     */
    @Override
    public boolean isTask() {
        return (!hasStartTime() && hasEndTime());
    }

    /**
     * Returns 1 for task
     * 2 for event
     * 3 for floating tasks
     */
    @Override
    public int getItemType() {
        if (isTask()) {
            return 1;
        } else if (isEvent()) {
            return 2;
        } else {
            return 3;
        }
    }

    // ================ Misc methods ==============================

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setStartTime(replacement.getStartTime());
        this.setEndTime(replacement.getDeadline());
        this.setIsDone(replacement.getIsDone());
        this.setDescription(replacement.getDescription());
        this.setTags(replacement.getTags());
    }


    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(this.name, this.priority, this.description, this.tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public boolean equals(Object other) {
        return (other == this // short circuit if same object
                    ) || ((other instanceof ReadOnlyTask // instanceof handles nulls
                    ) && this.isSameStateAs((ReadOnlyTask) other));
    }

}
```
###### \java\seedu\doit\model\item\UniqueTaskList.java
``` java
package seedu.doit.model.item;

import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.exceptions.DuplicateDataException;
import seedu.doit.commons.util.CollectionUtil;
import seedu.doit.model.comparators.TaskNameComparator;

/**
 * A list of tasks that enforces uniqueness between its elements and does not allow nulls.
 * <p>
 * Supports a minimal set of list operations.
 *
 * @see Task#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueTaskList implements Iterable<Task> {

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();
    private Comparator<ReadOnlyTask> taskComparator = new TaskNameComparator();

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(toAdd);
        internalList.sort(taskComparator);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedTask}.
     *
     * @throws DuplicateTaskException    if updating the task's details causes the task to be equivalent to
     *                                   another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedTask) throws DuplicateTaskException {
        assert editedTask != null;

        Task taskToUpdate = internalList.get(index);
        if (!taskToUpdate.equals(editedTask) && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        taskToUpdate.resetData(editedTask);
        // TODO: The code below is just a workaround to notify observers of the updated task.
        // The right way is to implement observable properties in the Task class.
        // Then, TaskCard should then bind its text labels to those observable properties.
        internalList.set(index, taskToUpdate);
        internalList.sort(taskComparator);
    }

    /**
     * Marks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void mark(int taskIndex, ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateTaskException {
        assert toMark != null;
        Task markedTask = new Task(toMark);
        markedTask.setIsDone(true);
        updateTask(taskIndex, markedTask);
        internalList.sort(taskComparator);
    }

    /**
     * Marks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void unmark(int taskIndex, ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateTaskException {
        assert toMark != null;
        Task markedTask = new Task(toMark);
        markedTask.setIsDone(false);
        updateTask(taskIndex, markedTask);
        internalList.sort(taskComparator);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        internalList.sort(taskComparator);
        return taskFoundAndDeleted;
    }

    public void setTasks(UniqueTaskList replacement) {
        this.internalList.setAll(replacement.internalList);
        internalList.sort(taskComparator);
    }

    public void setTasks(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {
        final UniqueTaskList replacement = new UniqueTaskList();
        for (final ReadOnlyTask task : tasks) {
            replacement.add(new Task(task));
        }
        setTasks(replacement);
    }

    public void setTaskComparator(Comparator<ReadOnlyTask> taskComparator) {
        this.taskComparator = taskComparator;
        internalList.sort(taskComparator);
    }

    public UnmodifiableObservableList<Task> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof UniqueTaskList // instanceof handles nulls
            && this.internalList.equals(
            ((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {
    }

}
```
###### \java\seedu\doit\model\Model.java
``` java
package seedu.doit.model;

import java.util.Set;

import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.exceptions.EmptyTaskManagerStackException;
import seedu.doit.logic.commands.exceptions.CommandExistedException;
import seedu.doit.logic.commands.exceptions.NoSuchCommandException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.item.UniqueTaskList.TaskNotFoundException;

/**
 * The API of the Model component.
 */
public interface Model {
    /**
     * Clears existing backing model and replaces with the provided new data.
     */
    void resetData(ReadOnlyItemManager newData);

    /**
     * Returns the TaskManager
     */
    ReadOnlyItemManager getTaskManager();

    /**
     * Deletes the given task.
     */
    void deleteTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;

    /**
     * Deletes the given task.
     */
    void deleteTasks(Set<ReadOnlyTask> targets) throws UniqueTaskList.TaskNotFoundException;

    /**
     * Adds the given task
     */
    void addTask(Task task) throws DuplicateTaskException;

    /**
     * Marks the given task as completed
     */
    void markTask(int taskIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException;

    /**
     * Marks the given task as uncompleted
     */
    void unmarkTask(int filteredTaskListIndex, ReadOnlyTask taskToDone)
            throws TaskNotFoundException, DuplicateTaskException;

    /**
     * Updates the task located at {@code filteredTaskListIndex} with
     * {@code editedTask}.
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be
     *             equivalent to another existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code filteredTaskListIndex} < 0 or >= the size of the
     *             filtered list.
     */
    void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) throws DuplicateTaskException;

    /**
     * Returns the filtered task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /**
     * Updates the filter of the filtered task list to show all undone tasks
     */
    void updateFilteredListToShowAll();

    /**
     * Updates the filter of the filtered task list to show all done tasks
     */
    void updateFilteredListToShowDone();

    /**
     * Updates the filter of the filtered task list to filter by the given
     * keywords
     */
    void updateFilteredTaskList(Set<String> nameKeywords, Set<String> priorityKeywords, Set<String> descriptionKeywords,
            Set<String> tagKeywords, Set<String> startTimekeywords, Set<String> endTimekeywords);

    /**
     * Set how the tasks are sorted
     */
    void sortBy(String sortType);

```
###### \java\seedu\doit\model\ModelManager.java
``` java
package seedu.doit.model;

import java.util.Set;
import java.util.function.Predicate;
import java.util.logging.Logger;

import javafx.collections.transformation.FilteredList;
import seedu.doit.commons.core.CommandSettings;
import seedu.doit.commons.core.ComponentManager;
import seedu.doit.commons.core.LogsCenter;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.events.model.TaskManagerChangedEvent;
import seedu.doit.commons.exceptions.EmptyTaskManagerStackException;
import seedu.doit.commons.util.CollectionUtil;
import seedu.doit.logic.commands.exceptions.CommandExistedException;
import seedu.doit.logic.commands.exceptions.NoSuchCommandException;
import seedu.doit.model.comparators.EndTimeComparator;
import seedu.doit.model.comparators.PriorityComparator;
import seedu.doit.model.comparators.StartTimeComparator;
import seedu.doit.model.comparators.TaskNameComparator;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.item.UniqueTaskList.TaskNotFoundException;
import seedu.doit.model.predicates.AlwaysTruePredicate;
import seedu.doit.model.predicates.DescriptionPredicate;
import seedu.doit.model.predicates.DonePredicate;
import seedu.doit.model.predicates.EndTimePredicate;
import seedu.doit.model.predicates.NamePredicate;
import seedu.doit.model.predicates.PriorityPredicate;
import seedu.doit.model.predicates.StartTimePredicate;
import seedu.doit.model.predicates.TagPredicate;

/**
 * Represents the in-memory model of the task manager data. All changes to any
 * model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private TaskManager taskManager;
    private FilteredList<ReadOnlyTask> filteredTasks;

    private static final TaskManagerStack taskManagerStack = TaskManagerStack.getInstance();

    /**
     * Initializes a ModelManager with the given taskManager and userPrefs.
     */
    public ModelManager(ReadOnlyItemManager taskManager, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(taskManager, userPrefs);

        logger.fine("Initializing with task manager: " + taskManager + " and user prefs " + userPrefs);

        this.taskManager = new TaskManager(taskManager);
        updateFilteredTasks();
        updateFilteredListToShowAll();

    }

```
###### \java\seedu\doit\model\ModelManager.java
``` java
    public ModelManager() {
        this(new TaskManager(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyItemManager newData) {
        this.taskManager.resetData(newData);
        indicateTaskManagerChanged();
    }

    @Override
    public void resetDataWithoutSaving(ReadOnlyItemManager newData) {
        this.taskManager.resetData(newData);
    }

    @Override
    public void loadData(ReadOnlyItemManager newData) {
        this.resetDataWithoutSaving(newData);
        taskManagerStack.clearRedoStack();
        taskManagerStack.clearUndoStack();
    }

```
###### \java\seedu\doit\model\ModelManager.java
``` java
    @Override
    public ReadOnlyItemManager getTaskManager() {
        return this.taskManager;
    }

    /**
     * Raises an event to indicate the model has changed
     */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(this.taskManager));
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        logger.info("delete task in model manager");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        this.taskManager.removeTask(target);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();

    }

    @Override
    public synchronized void deleteTasks(Set<ReadOnlyTask> targets) throws TaskNotFoundException {
        logger.info("delete task(s) in model manager");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        for (ReadOnlyTask target: targets) {
            this.taskManager.removeTask(target);
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws DuplicateTaskException {
        logger.info("add task in model manager");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        this.taskManager.addTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void markTask(int filteredTaskListIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        logger.info("marked a task in model manager as done");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        int taskManagerIndex = this.filteredTasks.getSourceIndex(filteredTaskListIndex);
        this.taskManager.markTask(taskManagerIndex, taskToDone);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void unmarkTask(int filteredTaskListIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        logger.info("marked a task in model manager as done");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        int taskManagerIndex = this.filteredTasks.getSourceIndex(filteredTaskListIndex);
        this.taskManager.unmarkTask(taskManagerIndex, taskToDone);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) throws DuplicateTaskException {
        assert editedTask != null;
        logger.info("update task in model manager");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        int taskManagerIndex = this.filteredTasks.getSourceIndex(filteredTaskListIndex);
        this.taskManager.updateTask(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
    }

    @Override
    public void sortBy(String sortType) {
        switch (sortType) {
        case "start time":
            this.taskManager.setTaskComparator(new StartTimeComparator());
            break;
        case "end time":
            this.taskManager.setTaskComparator(new EndTimeComparator());
            break;
        case "priority":
            this.taskManager.setTaskComparator(new PriorityComparator());
            break;
        case "name":
            // fallthrough
        default:
            this.taskManager.setTaskComparator(new TaskNameComparator());
            break;
        }
    }

```
###### \java\seedu\doit\model\ModelManager.java
``` java
    // =========== Filtered Task List Accessors
    // ============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(this.filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        this.filteredTasks.setPredicate(null);
        this.filteredTasks.setPredicate(new DonePredicate(false));
        indicateTaskManagerChanged();
    }

    @Override
    public void updateFilteredListToShowDone() {
        this.filteredTasks.setPredicate(null);
        this.filteredTasks.setPredicate(new DonePredicate(true));
        indicateTaskManagerChanged();
    }

    @Override
    public void updateFilteredTaskList(Set<String> nameKeywords, Set<String> priorityKeywords,
            Set<String> descriptionKeywords, Set<String> tagKeywords, Set<String> startTimekeywords,
            Set<String> endTimekeywords) {
        Predicate<ReadOnlyTask> combined = new AlwaysTruePredicate();

        if (!nameKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> namePredicate = new NamePredicate(nameKeywords);
            combined = combined.and(namePredicate);
        }
        if (!priorityKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> priorityPredicate = new PriorityPredicate(priorityKeywords);
            combined = combined.and(priorityPredicate);
        }
        if (!descriptionKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> descriptionPredicate = new DescriptionPredicate(descriptionKeywords);
            combined = combined.and(descriptionPredicate);
        }
        if (!tagKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> tagPredicate = new TagPredicate(tagKeywords);
            combined = combined.and(tagPredicate);
        }
        if (!startTimekeywords.isEmpty()) {
            Predicate<ReadOnlyTask> startTimePredicate = new StartTimePredicate(startTimekeywords);
            combined = combined.and(startTimePredicate);
        }
        if (!endTimekeywords.isEmpty()) {
            Predicate<ReadOnlyTask> endTimePredicate = new EndTimePredicate(endTimekeywords);
            combined = combined.and(endTimePredicate);
        }

        this.filteredTasks.setPredicate(combined);
    }
}
```
###### \java\seedu\doit\model\predicates\AlwaysTruePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.function.Predicate;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * A utility Predicate that will always return true
 */
public class AlwaysTruePredicate implements Predicate<ReadOnlyTask> {
    @Override
    public boolean test(ReadOnlyTask task) {
        return true;
    }
}
```
###### \java\seedu\doit\model\predicates\DescriptionPredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

/**
 * A predicate that will return true if the ReadOnlyTask description matches the
 * descriptionKeyWords
 */
public class DescriptionPredicate implements Predicate<ReadOnlyTask> {
    private Set<String> descriptionKeyWords;

    public DescriptionPredicate(Set<String> descriptionKeyWords) {
        this.descriptionKeyWords = descriptionKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.descriptionKeyWords.stream()
                .allMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getDescription().value, keyword));
    }
}
```
###### \java\seedu\doit\model\predicates\DonePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.function.Predicate;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * A predicate that will return true if the ReadOnlyTask isDone matches the
 * showDone boolean
 */
public class DonePredicate implements Predicate<ReadOnlyTask> {
    private boolean showDone;

    public DonePredicate(boolean showDone) {
        this.showDone = showDone;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return (task.getIsDone() == showDone);
    }
}
```
###### \java\seedu\doit\model\predicates\EndTimePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

public class EndTimePredicate implements Predicate<ReadOnlyTask> {
    private Set<String> endTimeKeyWords;

    public EndTimePredicate(Set<String> endTimeKeyWords) {
        this.endTimeKeyWords = endTimeKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        if (task.hasEndTime()) {
            return this.endTimeKeyWords.stream()
                    .anyMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getDeadline().value, keyword));
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\doit\model\predicates\NamePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

/**
* A predicate that will return true if the ReadOnlyTask name matches the
* nameKeyWords
*/
public class NamePredicate implements Predicate<ReadOnlyTask> {
    private Set<String> nameKeyWords;

    public NamePredicate(Set<String> nameKeyWords) {
        this.nameKeyWords = nameKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.nameKeyWords.stream()
                .allMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword));
    }
}
```
###### \java\seedu\doit\model\predicates\PriorityPredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

/**
* A predicate that will return true if the ReadOnlyTask priority matches the
* priorityKeyWords
*/
public class PriorityPredicate implements Predicate<ReadOnlyTask> {
    private Set<String> priorityKeyWords;

    public PriorityPredicate(Set<String> priorityKeyWords) {
        this.priorityKeyWords = priorityKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.priorityKeyWords.stream()
                .anyMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getPriority().value, keyword));
    }
}
```
###### \java\seedu\doit\model\predicates\StartTimePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

public class StartTimePredicate implements Predicate<ReadOnlyTask> {
    private Set<String> startTimeKeyWords;

    public StartTimePredicate(Set<String> endTimeKeyWords) {
        this.startTimeKeyWords = endTimeKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        if (task.hasStartTime()) {
            return this.startTimeKeyWords.stream()
                    .anyMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getStartTime().value, keyword));
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\doit\model\predicates\TagPredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.tag.Tag;

/**
* A predicate that will return true if any of the ReadOnlyTask tags matches the
* tagKeywords
*/
public class    TagPredicate implements Predicate<ReadOnlyTask> {
    private Set<String> tagKeywords;

    public TagPredicate(Set<String> tagKeywords) {
        this.tagKeywords = tagKeywords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.tagKeywords.stream().allMatch(keyword -> {
            try {
                return (task.getTags().contains(new Tag(keyword)));
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return false;
            }
        });
    }
}
```
###### \java\seedu\doit\model\ReadOnlyItemManager.java
``` java
package seedu.doit.model;

import javafx.collections.ObservableList;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.tag.Tag;

/**
 * Unmodifiable view of an task manager
 */
public interface ReadOnlyItemManager {

    /**
     * Returns an unmodifiable view of the task s list.
     * This list will not contain any duplicate task s.
     */
    ObservableList<ReadOnlyTask> getTaskList();

    /**
     * Returns an unmodifiable view of the tags list.
     * This list will not contain any duplicate tags.
     */
    ObservableList<Tag> getTagList();

}
```
###### \java\seedu\doit\model\tag\Tag.java
``` java
package seedu.doit.model.tag;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Tag in the task manager. Guarantees: immutable; name is valid as
 * declared in {@link #isValidTagName(String)}
 */
public class Tag {

    public static final String MESSAGE_TAG_CONSTRAINTS = "Tags names should be alphanumeric";
    public static final String TAG_VALIDATION_REGEX = "\\p{Alnum}+";

    public final String tagName;

    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException
     *             if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid tag name.
     */
    public static boolean isValidTagName(String test) {
        return test.matches(TAG_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Tag // instanceof handles nulls
            && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    /**
     * Format state as text for viewing.
     */
    @Override
    public String toString() {
        return '[' + tagName + ']';
    }

}
```
###### \java\seedu\doit\model\tag\UniqueTagList.java
``` java
package seedu.doit.model.tag;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.exceptions.DuplicateDataException;
import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.commons.util.CollectionUtil;

/**
 * A list of tags that enforces no nulls and uniqueness between its elements.
 * <p>
 * Supports minimal set of list operations for the app's features.
 *
 * @see Tag#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueTagList implements Iterable<Tag> {

    private final ObservableList<Tag> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty TagList.
     */
    public UniqueTagList() {
    }

    /**
     * Creates a UniqueTagList using given String tags.
     * Enforces no nulls or duplicates.
     */
    public UniqueTagList(String... tags) throws DuplicateTagException, IllegalValueException {
        final List<Tag> tagList = new ArrayList<Tag>();
        for (String tag : tags) {
            tagList.add(new Tag(tag));
        }
        setTags(tagList);
    }

    /**
     * Creates a UniqueTagList using given tags.
     * Enforces no nulls or duplicates.
     */
    public UniqueTagList(Tag... tags) throws DuplicateTagException {
        assert !CollectionUtil.isAnyNull((Object[]) tags);
        final List<Tag> initialTags = Arrays.asList(tags);
        if (!CollectionUtil.elementsAreUnique(initialTags)) {
            throw new DuplicateTagException();
        }
        internalList.addAll(initialTags);
    }

    /**
     * Creates a UniqueTagList using given tags.
     * Enforces no null or duplicate elements.
     */
    public UniqueTagList(Collection<Tag> tags) throws DuplicateTagException {
        this();
        setTags(tags);
    }

    /**
     * Creates a UniqueTagList using given tags.
     * Enforces no nulls.
     */
    public UniqueTagList(Set<Tag> tags) {
        assert !CollectionUtil.isAnyNull(tags);
        internalList.addAll(tags);
    }

    /**
     * Creates a copy of the given list.
     * Insulates from changes in source.
     */
    public UniqueTagList(UniqueTagList source) {
        internalList.addAll(source.internalList); // insulate internal list from changes in argument
    }

    /**
     * Returns all tags in this list as a Set.
     * This set is mutable and change-insulated against the internal list.
     */
    public Set<Tag> toSet() {
        return new HashSet<>(internalList);
    }

    /**
     * Replaces the Tags in this list with those in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTags(Collection<Tag> tags) throws DuplicateTagException {
        assert !CollectionUtil.isAnyNull(tags);
        if (!CollectionUtil.elementsAreUnique(tags)) {
            throw new DuplicateTagException();
        }
        internalList.setAll(tags);
    }

    /**
     * Ensures every tag in the argument list exists in this object.
     */
    public void mergeFrom(UniqueTagList from) {
        final Set<Tag> alreadyInside = this.toSet();
        from.internalList.stream()
            .filter(tag -> !alreadyInside.contains(tag))
            .forEach(internalList::add);
    }

    /**
     * Returns true if the list contains an equivalent Tag as the given argument.
     */
    public boolean contains(Tag toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a Tag to the list.
     *
     * @throws DuplicateTagException if the Tag to add is a duplicate of an existing Tag in the list.
     */
    public void add(Tag toAdd) throws DuplicateTagException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTagException();
        }
        internalList.add(toAdd);
    }

    @Override
    public Iterator<Tag> iterator() {
        return internalList.iterator();
    }

    public UnmodifiableObservableList<Tag> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof UniqueTagList // instanceof handles nulls
            && this.internalList.equals(
            ((UniqueTagList) other).internalList));
    }

    public boolean equalsOrderInsensitive(UniqueTagList other) {
        return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTagException extends DuplicateDataException {
        protected DuplicateTagException() {
            super("Operation would result in duplicate tags");
        }
    }

}
```
###### \java\seedu\doit\model\TaskManager.java
``` java
package seedu.doit.model;

import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import javafx.collections.ObservableList;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.item.UniqueTaskList.TaskNotFoundException;
import seedu.doit.model.tag.Tag;
import seedu.doit.model.tag.UniqueTagList;

/**
 * Wraps all data at the task manager level
 * Duplicates are not allowed (by .equals comparison)
 */
public class TaskManager implements ReadOnlyItemManager {

    private final UniqueTaskList tasks;
    private final UniqueTagList tags;

    /*
     * The 'unusual' code block below is an non-static initialization block, sometimes used to avoid duplication
     * between constructors. See https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
     *
     * Note that non-static init blocks are not recommended to use. There are other ways to avoid duplication
     *   among constructors.
     */ {
        tasks = new UniqueTaskList();
        tags = new UniqueTagList();
    }

    public TaskManager() {
    }

    /**
     * Creates an TaskManager using the Tasks and Tags in the {@code toBeCopied}
     */
    public TaskManager(ReadOnlyItemManager toBeCopied) {
        this();
        resetData(toBeCopied);
    }

//// list overwrite operations

    public void setTasks(List<? extends ReadOnlyTask> tasks)
        throws UniqueTaskList.DuplicateTaskException {
        this.tasks.setTasks(tasks);
    }

    public void setTags(Collection<Tag> tags) throws UniqueTagList.DuplicateTagException {
        this.tags.setTags(tags);
    }

    public void resetData(ReadOnlyItemManager newData) {
        assert newData != null;
        try {
            setTasks(newData.getTaskList());
        } catch (UniqueTaskList.DuplicateTaskException e) {
            assert false : "Task Manager should not have duplicate tasks";
        }
        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "Task Manager should not have duplicate tags";
        }
        syncMasterTagListWith(tasks);
    }

    public void setTaskComparator(Comparator<ReadOnlyTask> taskComparator) {
        tasks.setTaskComparator(taskComparator);
    }

//// task-level operations

    /**
     * Adds a task to the task manager.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws UniqueTaskList.DuplicateTaskException {
        syncMasterTagListWith(p);
        tasks.add(p);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyTask}.
     * {@code TaskManager}'s tag list will be updated with the tags of {@code editedReadOnlyTask}.
     *
     * @throws DuplicateTaskException    if updating the task's details causes the task to be equivalent to
     *                                   another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     * @see #syncMasterTagListWith(Task)
     */
    public void updateTask(int index, ReadOnlyTask editedReadOnlyTask)
        throws UniqueTaskList.DuplicateTaskException {
        assert editedReadOnlyTask != null;

        Task editedTask = new Task(editedReadOnlyTask);
        syncMasterTagListWith(editedTask);
        // TODO: the tags master list will be updated even though the below line fails.
        // This can cause the tags master list to have additional tags that are not tagged to any task
        // in the task list.
        tasks.updateTask(index, editedTask);
    }

    /**
     * Marks an existing task in the to-do list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void markTask(int taskIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        tasks.mark(taskIndex, taskToDone);
    }


    /**
     * Marks an existing task in the to-do list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void unmarkTask(int taskIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        tasks.unmark(taskIndex, taskToDone);
    }

    /**
     * Ensures that every tag in this task:
     * - exists in the master list {@link #tags}
     * - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        // used for checking task tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of task tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        taskTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        task.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these tasks:
     * - exists in the master list {@link #tags}
     * - points to a Tag object in the master list
     *
     * @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueTaskList tasks) {
        tasks.forEach(this::syncMasterTagListWith);
    }

    public boolean removeTask(ReadOnlyTask key) throws TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return tasks.asObservableList().size() + " tasks, " + tags.asObservableList().size() + " tags";
        // TODO: refine later
    }

    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        return new UnmodifiableObservableList<>(tasks.asObservableList());
    }

    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tags.asObservableList());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TaskManager // instanceof handles nulls
            && this.tasks.equals(((TaskManager) other).tasks)
            && this.tags.equalsOrderInsensitive(((TaskManager) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, tags);
    }
}
```
###### \java\seedu\doit\model\UserPrefs.java
``` java
package seedu.doit.model;

import seedu.doit.commons.core.CommandSettings;
import seedu.doit.commons.core.GuiSettings;

/**
 * Represents User's preferences.
 */
public class UserPrefs {

    private GuiSettings guiSettings;

    private CommandSettings commandSettings;

    public UserPrefs() {
        this.setGuiSettings(1100, 650, 150, 40);
        this.commandSettings = CommandSettings.getInstance();
    }

    public GuiSettings getGuiSettings() {
        return this.guiSettings == null ? new GuiSettings() : this.guiSettings;
    }

```
###### \java\seedu\doit\model\util\SampleDataUtil.java
``` java
package seedu.doit.model.util;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.model.ReadOnlyItemManager;
import seedu.doit.model.TaskManager;
import seedu.doit.model.item.Description;
import seedu.doit.model.item.EndTime;
import seedu.doit.model.item.Name;
import seedu.doit.model.item.Priority;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.tag.UniqueTagList;

/**
 * Represents sample data of tasks that will be loaded into TaskManager if the
 * data file is not found on startup
 */
public class SampleDataUtil {
    public static Task[] getSampleTasks() {
        try {
            return new Task[] { new Task(new Name("Refactor"), new Priority("low"), new EndTime("today"),
                    new Description("Refactor all mentions of task / taskManager"),
                    new UniqueTagList("Huanhui")),
                new Task(new Name("pass Travis"), new Priority("med"), new EndTime("today"),
                    new Description("Remove trailing whitespaces in md files for Travis to pass"),
                    new UniqueTagList("keanwai", "z")),
                new Task(new Name("help"), new Priority("high"), new EndTime("today"),
                    new Description("Update help command"),
                    new UniqueTagList("ChiaSin")),
                new Task(new Name("merge"), new Priority("med"), new EndTime("today"),
                    new Description("Fix the master branch merge conflicts"),
                    new UniqueTagList("JinShun")),
                new Task(new Name("help botton"), new Priority("high"), new EndTime("next week"),
                    new Description("Update Help button to our user guide"),
                    new UniqueTagList("ChiaSin")),
                new Task(new Name("UI interface"), new Priority("low"), new EndTime("next week"),
                    new Description("have 3 lists"),
                    new UniqueTagList("Huanhui")),
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }

    public static ReadOnlyItemManager getSampleTaskManager() {
        try {
            TaskManager sampleAB = new TaskManager();
            for (Task sampleTask : getSampleTasks()) {
                sampleAB.addTask(sampleTask);
            }
            return sampleAB;
        } catch (DuplicateTaskException e) {
            throw new AssertionError("sample data cannot contain duplicate tasks", e);
        }
    }
}
```
